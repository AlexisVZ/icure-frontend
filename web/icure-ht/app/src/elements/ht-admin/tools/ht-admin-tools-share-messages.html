
<link rel="import" href="../../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../../bower_components/iron-meta/iron-meta.html">
<link rel="import" href="../../../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../../../bower_components/iron-iconset-svg/iron-iconset-svg.html">
<link rel="import" href="../../../../bower_components/iron-iconset/iron-iconset.html">

<link rel="import" href="../../../../bower_components/iron-icons/iron-icons.html">
<link rel="import" href="../../../../bower_components/iron-icons/maps-icons.html">
<link rel="import" href="../../../../bower_components/iron-icons/social-icons.html">
<link rel="import" href="../../../../bower_components/iron-icons/device-icons.html">
<link rel="import" href="../../../../bower_components/iron-icons/av-icons.html">
<link rel="import" href="../../../../bower_components/iron-icons/hardware-icons.html">
<link rel="import" href="../../../../bower_components/iron-icons/editor-icons.html">
<link rel="import" href="../../../../bower_components/iron-icons/communication-icons.html">
<link rel="import" href="../../../../bower_components/iron-icons/image-icons.html">
<link rel="import" href="../../../../bower_components/iron-icons/maps-icons.html">
<link rel="import" href="../../../../bower_components/iron-icon/iron-icon.html">
<link rel="import" href="../../../../bower_components/iron-collapse-button/iron-collapse-button.html">
<link rel="import" href="../../../../bower_components/vaadin-material-theme/vaadin-grid.html">
<link rel="import" href="../../../../bower_components/vaadin-grid/vaadin-grid.html">
<link rel="import" href="../../../../bower_components/vaadin-grid/vaadin-grid-column.html">
<link rel="import" href="../../../../bower_components/paper-card/paper-card.html">
<link rel="import" href="../../../../bower_components/paper-listbox/paper-listbox.html">
<link rel="import" href="../../../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../../../../bower_components/paper-fab/paper-fab.html">
<link rel="import" href="../../../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../../../bower_components/paper-styles/shadow.html">
<link rel="import" href="../../../../bower_components/paper-tooltip/paper-tooltip.html">
<link rel="import" href="../../../../bower_components/paper-toast/paper-toast.html">
<link rel="import" href="../../../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../../../bower_components/paper-input/paper-input-container.html">
<link rel="import" href="../../../../bower_components/paper-input/paper-textarea.html">
<link rel="import" href="../../../dialog-style.html">

<link rel="import" href="../../../shared-styles.html">


<dom-module id="ht-admin-tools-share-messages">

    <template>

        <style include="shared-styles dialog-styles">

            .share-messages{
                height: calc(100vh - 84px);
                width: 100%;
                padding: 0 20px 24px 20px;
                box-sizing: border-box;
                position: relative;
            }

            vaadin-grid.material {

                font-family: Roboto, sans-serif;
                --divider-color: rgba(0, 0, 0, var(--dark-divider-opacity));

                --vaadin-grid-cell: {
                    padding: 8px;
                };

                --vaadin-grid-header-cell: {
                    height: 64px;
                    color: rgba(0, 0, 0, var(--dark-secondary-opacity));
                    font-size: 12px;
                };

                --vaadin-grid-body-cell: {
                    height: 48px;
                    color: rgba(0, 0, 0, var(--dark-primary-opacity));
                    font-size: 13px;
                };

                --vaadin-grid-body-row-hover-cell: {
                    background-color: var(--paper-grey-200);
                };

                --vaadin-grid-body-row-selected-cell: {
                    background-color: var(--paper-grey-100);
                };

                --vaadin-grid-focused-cell: {
                    box-shadow: none;
                    font-weight: bold;
                };
            }

            vaadin-grid.material .cell {
                overflow: hidden;
                text-overflow: ellipsis;
                padding-right: 0;
            }

            vaadin-grid.material .cell.last {
                padding-right: 24px;
            }

            vaadin-grid.material paper-checkbox {
                --primary-color: var(--paper-indigo-500);
                margin: 0 24px;
            }

            vaadin-grid.material vaadin-grid-sorter .cell {
                flex: 1;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            vaadin-grid.material vaadin-grid-sorter iron-icon {
                transform: scale(0.8);
            }

            vaadin-grid.material vaadin-grid-sorter:not([direction]) iron-icon {
                color: rgba(0, 0, 0, var(--dark-disabled-opacity));
            }

            vaadin-grid.material vaadin-grid-sorter[direction] {
                color: rgba(0, 0, 0, var(--dark-primary-opacity));
            }

            vaadin-grid.material vaadin-grid-sorter[direction=desc] iron-icon {
                transform: scale(0.8) rotate(180deg);
            }

                #shareMessageDialog {
                    width: 1000px;
                    /* height: 60vh; */
                }

                #shareMessageDialog .content{
                    padding-bottom: 24px;
                }

                #shareMessageDialog vaadin-grid{
                    min-height: 400px;
                    margin-top: 24px;
                }

                #shareMessageDialog #hcpFilter, #hcp-list {
                    margin: 0;
                }
                #shareMessageDialog #hcpFilter {
                    max-height: 62px;
                }
                #shareMessageDialog #hcp-list {
                    height: calc(100% - 24px - 64px);
                }

                #shareMessageDialog .buttons paper-checkbox{
                    --paper-checkbox-checked-color: var(--app-secondary-color);
                }

            #sharingMessageStatus {
                width: 50%;
                display: flex;
                flex-direction: column;
            }

            #sharingMessageStatus vaadin-grid {
                width: calc(100% - 96px);
                margin: auto;
            }

        </style>

        <div class="share-messages flex col">

            <h4>[[localize('to_share_messages', 'Partager des messages', language)]]</h4>

            <paper-dialog id="shareMessageDialog">
                <h2 class="modal-title">[[localize('share_message_to_what_hcp','With which provider do you want to share these messages',language)]] ?</h2>
                <div class="content">
                    <paper-input id="hcpFilter" label="[[localize('fil','Filter',language)]]" value="{{hcpFilterValue}}"></paper-input>
                    <vaadin-grid id="hcp-list" class="material" multi-sort="[[multiSort]]" items="[[hcp]]" active-item="{{activeHcp}}">
                        <vaadin-grid-column width="40px">
                            <template class="header">
                                <vaadin-checkbox on-checked-changed="_toggleBoxes"></vaadin-checkbox>
                            </template>
                            <template>
                                <vaadin-checkbox class="checkbox" id="[[item.id]]" checked="[[_sharingHcp(item, hcp.*)]]" on-checked-changed="_checkHcp" disabled="[[shareAll]]"></vaadin-checkbox>
                            </template>
                        </vaadin-grid-column>
                        <vaadin-grid-column width="100px">
                            <template class="header">
                                <vaadin-grid-sorter path="lastName">[[localize('las_nam','Last name',language)]]
                                </vaadin-grid-sorter>
                            </template>
                            <template>
                                <div class="cell frozen">[[_any(item.lastName, item.name, item)]]</div>
                            </template>
                        </vaadin-grid-column>
                        <vaadin-grid-column width="100px">
                            <template class="header">
                                <vaadin-grid-sorter path="firstName">[[localize('fir_nam','First name',language)]]
                                </vaadin-grid-sorter>
                            </template>
                            <template>
                                <div class="cell frozen">[[item.firstName]]</div>
                            </template>
                        </vaadin-grid-column>
                        <vaadin-grid-column width="100px">
                            <template class="header">
                                <vaadin-grid-sorter path="speciality">[[localize('spe','Speciality',language)]]
                                </vaadin-grid-sorter>
                            </template>
                            <template>
                                <div class="cell frozen">[[item.speciality]]</div>
                            </template>
                        </vaadin-grid-column>
                        <vaadin-grid-column width="100px">
                            <template class="header">
                                <vaadin-grid-sorter path="email">[[localize('ema','Email',language)]]
                                </vaadin-grid-sorter>
                            </template>
                            <template>
                                <div class="cell frozen">[[item.email]]</div>
                            </template>
                        </vaadin-grid-column>
                    </vaadin-grid>
                </div>
                <div class="buttons">
                    <paper-checkbox on-checked-changed="displayAllHcps">[[localize('disp_all_hcps','Display all HCPs', language)]]</paper-checkbox>
                    <paper-button class="modal-button" dialog-dismiss>[[localize('can','Cancel',language)]]</paper-button>
                    <paper-button class="modal-button modal-button--save" dialog-confirm autofocus on-tap="confirmSharing">[[localize('share_messages','Share
                        messages',language)]]
                    </paper-button>
                </div>
            </paper-dialog>

            <paper-dialog id="sharingMessageStatus">
                <h2 class="modal-title">[[localize("mes_sha_sta","Message sharing status",language)]]</h2>
                <div class="content">
                    <ht-spinner class="sharePatSpinner" active="[[isSharingMessage]]"></ht-spinner>
                    <vaadin-grid items="[[messageShareStatuses]]">
                        <vaadin-grid-column width="150px">
                            <template class="header">
                                [[localize('message','Message',language)]]
                            </template>
                            <template>
                                [[item.message.id]] [[item.message.transportGuid]]
                            </template>
                        </vaadin-grid-column>
                        <vaadin-grid-column width="70px">
                            <template class="header">
                                [[localize('message','Message',language)]]
                            </template>
                            <template>
                                <span class$="[[_statusDetailClass(item.statuses.message)]]">[[_statusDetail(item.statuses.message)]]</span>
                            </template>
                        </vaadin-grid-column>
                        <vaadin-grid-column width="70px">
                            <template class="header">
                                Invoices
                            </template>
                            <template>
                                <span class$="[[_statusDetailClass(item.statuses.invoices)]]">[[_statusDetail(item.statuses.invoices)]]</span>
                            </template>
                        </vaadin-grid-column>
                        <vaadin-grid-column width="70px">
                            <template class="header">
                                [[localize('files','Files',language)]]
                            </template>
                            <template>
                                <span class$="[[_statusDetailClass(item.statuses.documents)]]">[[_statusDetail(item.statuses.documents)]]</span>
                            </template>
                        </vaadin-grid-column>
                    </vaadin-grid>
                </div>
                <div class="buttons">
                    <paper-button class="modal-button modal-button--save" dialog-dismiss>[[localize('done','Done',language)]]</paper-button>
                </div>
            </paper-dialog>



            <vaadin-grid id="messageGrid" class="material grow-1" items="[[messagesItems]]" active-item="{{selectedMessage}}">
                <vaadin-grid-column flex-grow="0" width="48px">
                    <template class="header">
                        <vaadin-checkbox checked$="[[allSelected]]" on-tap="_toggleSelectAll"></vaadin-checkbox>
                    </template>
                    <template>
                        <vaadin-checkbox data-item$="[[item]]" on-checked-changed="_itemSelected" class="list-checkbox"></vaadin-checkbox>
                    </template>
                </vaadin-grid-column>
                <vaadin-grid-column>
                    <template class="header">
                        messages
                    </template>
                    <template>
                        <div>[[item.id]]</div>
                    </template>
                </vaadin-grid-column>
                <vaadin-grid-column>
                    <template class="header">
                        transportGuid
                    </template>
                    <template>
                        <div>[[item.transportGuid]]</div>
                    </template>
                </vaadin-grid-column>
                <vaadin-grid-column>
                    <template class="header">
                        fromAddress
                    </template>
                    <template>
                        <div>[[item.fromAddress]]</div>
                    </template>
                </vaadin-grid-column>
                <vaadin-grid-column>
                    <template class="header">
                        created
                    </template>
                    <template>
                        <div>[[dateLabel(item.created)]]</div>
                    </template>
                </vaadin-grid-column>
            </vaadin-grid>
            <div class="flex space-between">
                <paper-button class="modal-button modal-button--save export-btn" on-tap="_openMessageSharingDialog">[[localize('share_messages','Partager les messages',language)]] </paper-button>
            </div>
        </div>
    </template>

    <script>
        import * as models from 'icc-api/dist/icc-api/model/models';

        import { retry } from "icc-api/dist/icc-x-api/utils/net-utils"

        class HtAdminToolsShareMessages extends Polymer.TkLocalizerMixin(Polymer.Element) {
            static get is() {
                return 'ht-admin-tools-share-messages'
            }

            static get properties() {
                return {
                    api: {
                        type: Object,
                        noReset: true
                    },
                    user: {
                        type: Object,
                        noReset: true
                    },
                    credentials:{
                        type: Object,
                        noReset: true
                    },
                    hcpFilterValue: {
                        type: String
                    },
                    hcpSelectedForSharing: {
                        type: Object,
                        notify: true,
                        value: () => []
                    },
                    selectedMessagesForSharing: {
                        type: Object,
                        notify: true,
                        value: () => []
                    },
                    _allHcpsChecked: {
                        type: Boolean,
                        value: false

                    },
                    hcp: {
                        type: Object
                    },
                }
            }

            static get observers() {
                return ['_selectedFilterIndexesChanged(selectedFilterIndexes.splices)', '_filterValueChanged(filterValue)', '_showInactivePatientsChanged(showInactive)', '_hcpFilterChanged(hcpFilterValue, _allHcpsChecked)', '_filesChanged(files.*)','_canAddPat(lastName,firstName,dateAsString)']
            }

            constructor() {
                super()
            }

            ready() {
                super.ready()
                this.set('currentHcps', _.values(this.api.hcParties))
                this.refreshMessageList()
            }

            _checkHcp(e) {
                if (e.target.id !== "") {
                    const mark = this.hcpSelectedForSharing.find(m => m.id === e.target.id)
                    if (!mark) {
                        this.push('hcpSelectedForSharing', {
                            id: e.target.id,
                            check: true,
                            delegation: ["all"]
                        })
                    } else {
                        mark.check = !mark.check
                        this.notifyPath('hcpSelectedForSharing.*')
                    }
                }

            }

            displayAllHcps(checked) {
                this._allHcpsChecked = checked.detail.value
            }

            _any(a,b,c) {
                return a || b
            }

            _hcpFilterChanged(e) {
                let latestSearchValue = this.hcpFilterValue
                this.latestSearchValue = latestSearchValue

                if (!latestSearchValue || latestSearchValue.length < 2) {
                    console.log("Cancelling empty search")
                    const hcps = (_.values(this.api.hcParties || {}) || []).filter(hcp => hcp.publicKey && (!hcp.parentId || this._allHcpsChecked) && ((hcp.lastName || '').length || (hcp.name || '').length))
                    this.set('hcp', _.orderBy(hcps, ['lastName'], ['asc']))
                    return
                }
                this._hcpDataProvider() && this._hcpDataProvider().filter(latestSearchValue).then(res => {
                    if (latestSearchValue !== this.latestSearchValue) {
                        console.log("Cancelling obsolete search")
                        return
                    }
                    this.set('hcp', res.rows)
                })
            }

            confirmSharingNextStep(allHcp) {
                // NOTE: this stage is skiped in GUI but still needed to update variables

                //erase uncheck user
                if (this.shareAll ||(allHcp === true)) {
                    this.set('hcpSelectedForSharing',this.hcp)
                } else {
                    const tab = _.differenceBy(this.hcpSelectedForSharing, [{'check': false}], 'check')
                    this.set("hcpSelectedForSharing", tab)
                }

                //loading existing delegation of shared users
                this.hcpSelectedForSharing.forEach((userShared, index) => {
                    let delegationTag = []
                    const keys = Object.keys(this.user.autoDelegations)
                    keys.forEach(key => {
                        if (this.user.autoDelegations[key].find(x => x === userShared.id))
                            delegationTag.push(key)
                    })
                    if (delegationTag.length !== 0)
                        this.set("hcpSelectedForSharing." + index + ".delegation", delegationTag)
                })

                //this.$['sharePatientDelegationDialog'].open()
            }

            _hcpDataProvider() {
                return {
                    filter: (hcpFilterValue) => {
                        const desc = 'desc'
                        let count = 15
                        return Promise.all([this.api.hcparty().findByName(hcpFilterValue, null, null, count, desc)]).then(results => {
                            const hcpList = results[0]
                            const filtered = _.flatten(hcpList.rows.filter(hcp => hcp.publicKey && ((hcp.lastName || '').length || (hcp.name || '').length)).map(hcp => ({
                                id: hcp.id,
                                lastName: hcp.lastName,
                                firstName: hcp.firstName,
                                speciality: hcp.speciality,
                                email: hcp.email
                            })))
                            return {totalSize: filtered.length, rows: filtered}
                        })

                    }
                }
            }

            _statusDetail(status) {
                return status.success === null ? 'N/A' : status.success ? 'OK' : status.error && status.error.message || 'NOK'
            }

            _statusDetailClass(status) {
                return status.success === null ? '' : status.success ? 'status-green' : 'status-red'
            }

            _sharingHcp(item) {
                if (this.shareAll == true ) {
                    return true
                } else if (item) {
                    const mark = this.hcpSelectedForSharing.find(m => m.id === item.id)
                    return mark && mark.check
                } else {
                    return false
                }
            }

            checkingDelegation(tagInput, delegations) {
                if (!delegations) return
                return delegations.find(x => x === tagInput)
            }

            updateDelegation() {
                if (!this.user) return
                let userDelegation = this.user.autoDelegations

                this.hcpSelectedForSharing.forEach(userShared => {
                        //delete old delegations for this user
                        Object.keys(userDelegation).forEach(key => {
                            userDelegation[key] = userDelegation[key].filter(x => x !== userShared.id)
                            if (userDelegation[key].length === 0) delete userDelegation[key]
                        })

                        userShared.delegation.forEach(delegationTag => {
                            //add news delegations for this user
                            if (userDelegation.hasOwnProperty(delegationTag)) {
                                userDelegation[delegationTag].push(userShared.id)
                            }
                            else {
                                userDelegation[delegationTag] = [userShared.id]
                            }
                        })
                    }
                )
                this.set("user.autoDelegations", userDelegation)

                this.api.user().modifyUser(this.user).then(user => {
                    this.dispatchEvent(new CustomEvent('user-saved', {
                        detail: user,
                        bubbles: true,
                        composed: true
                    }))
                }).catch(e => {
                    console.log(e)
                }).finally(e => {
                    this.api.user().getUser(this.user.id).then(x => {
                        this.set("user", x)
                    })
                })
            }

            _showAllDelegation(tag, id) {

                if (tag === "all") return true
                const index = this.hcpSelectedForSharing.findIndex(x => x.id === id)
                if (index === -1) return false

                let value = !this.hcpSelectedForSharing[index].delegation.find(x => x === "all")
                if (tag.includes("cdItem") && this.hcpSelectedForSharing[index].delegation.find(x => x === "medicalInformation"))
                    value = false
                return value
            }

            dateLabel(date) {
                return this.api.moment(date).format("DD-MM-YYYY")
            }

            _itemSelected(e) {
                if (e.path[0].checked) {
                    const checked = JSON.parse(e.target.dataset.item)
                    if (this.selectedMessagesForSharing.length < this.messagesItems.length) this.push('selectedMessagesForSharing', checked)
                } else {
                    this.splice('selectedMessagesForSharing', this.selectedMessagesForSharing.indexOf(e.target.dataset.item))
                    this.set('allSelected',false)
                }
                console.log(this.selectedMessagesForSharing.length+' checked',this.selectedMessagesForSharing)
            }


            _toggleSelectAll() {
                this.set('allSelected',this.allSelected != null ? !this.allSelected : true)
                this.set('selectedMessagesForSharing',this.allSelected ? this.messagesItems : [])
                let invList = this.shadowRoot.querySelector('#messageGrid');
                let allCheckboxes = invList? invList.querySelectorAll('.list-checkbox') : []
                const selectedState = this.allSelected
                allCheckboxes.forEach(box=>{
                    box.checked = selectedState;
                })
            }

            getAllMessagesByTranportGuid(guid) {
                return this.api.hcparty().getCurrentHealthcareParty().then(hcp => {
                    return this.api.getRowsUsingPagination(
                        (key,docId) =>
                            this.api.message().findMessagesByTransportGuid(guid, null, key, docId, 1000, hcp.id)
                                .then(pl => {
                                    console.log("my rows", pl.rows)
                                    return {
                                        rows: pl.rows,
                                        nextKey: pl.nextKeyPair && pl.nextKeyPair.startKey,
                                        nextDocId: pl.nextKeyPair && pl.nextKeyPair.startKeyDocId,
                                        done: !pl.nextKeyPair
                                    }
                                })
                                .catch(error=>{
                                    console.log("error", error)
                                    return Promise.resolve();
                                })
                    ).then(rows => {
                        if(hcp.parentId) {
                            return this.api.getRowsUsingPagination(
                                (key,docId) =>
                                    this.api.message().findMessagesByTransportGuid(guid, null, key, docId, 1000, hcp.parentId)
                                        .then(pl => {
                                            console.log("my rows", pl.rows)
                                            return {
                                                rows: pl.rows,
                                                nextKey: pl.nextKeyPair && pl.nextKeyPair.startKey,
                                                nextDocId: pl.nextKeyPair && pl.nextKeyPair.startKeyDocId,
                                                done: !pl.nextKeyPair
                                            }
                                        })
                                        .catch(error=>{
                                            console.log("error", error)
                                            return Promise.resolve();
                                        })
                            ).then(moreRows=> {
                                return _.uniqBy(_.concat(rows, moreRows), 'id')
                            })
                        } else {
                            return rows
                        }
                    })
                })
            }

            refreshMessageList() {
                return this.getAllMessagesByTranportGuid("EFACT:*").then(messages=> {
                    console.log("messages", messages)
                    this.set('messagesItems', messages)
                    this.set('selectedMessagesForSharing', [])

                })

            }

            _openMessageSharingDialog() {
                this.$['shareMessageDialog'].open()
                this.set('hcp', _.orderBy(_.values(this.api.hcParties), ['lastName'], ['asc']))
                //this.selectedMessagesForSharing = this.selectedMessagesForSharing.filter(pat => pat.check && pat.id)
            }

            confirmSharing() {
                this.confirmSharingNextStep(false)
                this.updateDelegation()

                this.$['shareMessageDialog'].close()
                this.$['sharingMessageStatus'].open()

                this._shareMessages(this.selectedMessagesForSharing)
            }

            _hashCode(str) {
                return str.split('').reduce((prevHash, currVal) =>
                    (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0)
            }

            _shareMessages(messages) {
                console.log("sharing messages", messages)
                this.set('messageShareStatuses', [])
                this.set('isSharingMessage',true)

                const hcpId = this.user.healthcarePartyId
                const delegates = this.hcpSelectedForSharing.filter(hcp => hcp.check && hcp.id)
                const delegationTags = _.fromPairs(delegates.map(hcp => [hcp.id, _.sortBy(hcp.delegation)]))
                const sig = this._hashCode(JSON.stringify(_.sortBy(delegationTags, x => x[0])))
                const locStoTag = `org.taktik.icure.${this.user.id}.shareMessages.${sig}.progress`

                let prevRunIds = JSON.parse(localStorage.getItem(locStoTag) || '[]')
                prevRunIds = [] // added for debug

                this.messageSharePromise = Promise.resolve([[], prevRunIds])

                _.chunk(messages.filter(p => !prevRunIds.includes(p.id)), 16).forEach(chunk => {
                    this.messageSharePromise = this.messageSharePromise.then(([prevStatuses, treatedIds]) => Promise.all(chunk.map(mes =>
                            this.api_message_share(this.user, mes.id, hcpId, delegates.map(hcp => hcp.id), delegationTags)
                                .catch(e => {
                                    console.log(e)
                                    return {
                                        message: mes, statuses: {
                                            invoices: {success: null, error: null},
                                            documents: {success: null, error: null},
                                            message: {success: false, error: e}
                                        }
                                    }
                                })
                        )).then(statuses => {
                            const newStatuses = prevStatuses.concat(statuses)
                            const newTreatedIds = treatedIds.concat(statuses.filter(s => !_.values(s.statuses).some(s => !s.success)).map(s => s.message.id))
                            localStorage.setItem(locStoTag, JSON.stringify(newTreatedIds))
                            this.push('messageShareStatuses', ...statuses)

                            this.dispatchEvent(new CustomEvent('idle', {bubbles: true, composed: true}))

                            return [newStatuses, newTreatedIds]
                        })
                    )
                });
                this.messageSharePromise.then(()=>this.set('isSharingMessage',false))
            }


            api_message_share(user, mesId, ownerId, delegateIds, delegationTags) {
                console.log("---- shareing message: ", mesId)
                return this.api.hcparty().getHealthcareParty(ownerId).then(hcp => {
                    const parentId = hcp.parentId;
                    const allTags = _.uniq(_.flatMap(Object.values(delegationTags)));
                    const status = {
                        invoices: {
                            success: allTags.includes("financialInformation") || allTags.includes("all") ? false : null,
                            error: null
                        },
                        documents: {
                            success: allTags.includes("medicalInformation") || allTags.includes("all") ? false : null,
                            error: null
                        },
                        message: { success: false, error: null }
                    };
                    return retry(() => this.api.message().getMessage(mesId)).then((message) => {
                        console.log("message cFKs:", message.cryptedForeignKeys)
                        return this.extractDelegationsSFKsAndEncryptionSKs(message, ownerId).then(([delSfks, ecKeys]) => {
                            return delSfks.length
                                ? Promise.all([
                                    // get docs stubs
                                    retry(() => this.api_document_findDelegationsStubsByHCPartyMessageSecretFKeys(ownerId, delSfks.join(","))
                                        .then(docs => parentId ?
                                            this.api_document_findDelegationsStubsByHCPartyMessageSecretFKeys(parentId, delSfks.join(","))
                                                .then(moreDocs => _.uniqBy(docs.concat(moreDocs), "id"))
                                            : docs)),
                                ]).then(([docs]) => {
                                    // clone docs stubs
                                    const oDocs = docs.map(x => _.assign({}, x, {
                                        delegations: _.clone(x.delegations),
                                        cryptedForeignKeys: _.clone(x.cryptedForeignKeys),
                                        encryptionKeys: _.clone(x.encryptionKeys)
                                    }));
                                    // get invoices
                                    const invIds = message.invoiceIds;
                                    // get invoices
                                    return retry(() => this.api.invoice().getInvoices(new models.ListOfIdsDto({ ids: invIds }))).then((ivs) => {
                                        // clone invoices stubs
                                        const oInvs = ivs.map(x => _.assign({}, x, {
                                            delegations: _.clone(x.delegations),
                                            cryptedForeignKeys: _.clone(x.cryptedForeignKeys),
                                            encryptionKeys: _.clone(x.encryptionKeys)
                                        }));
                                        let markerPromise = Promise.resolve(null);
                                        delegateIds.forEach(delegateId => {
                                            const tags = delegationTags[delegateId];

                                            //Share message
                                            markerPromise = markerPromise.then(() => {
                                                console.log(`share message ${message.id} to ${delegateId}`);
                                                return this.api.crypto()
                                                    .addDelegationsAndEncryptionKeys(null, message, ownerId, delegateId, delSfks[0], ecKeys[0])
                                                    .catch(e => {
                                                        console.log("error when sharing message", e);
                                                        return message;
                                                    });
                                            });

                                            // share invoices
                                            tags.includes("financialInformation") ||
                                            (tags.includes("all") &&
                                                ivs.forEach(x => (markerPromise = markerPromise.then(() => Promise.all([
                                                    this.api.crypto().extractDelegationsSFKs(x, ownerId),
                                                    this.api.crypto().extractEncryptionsSKs(x, ownerId)
                                                ]).then(([sfks, eks]) => {
                                                    console.log(`share message ${message.id} invoice ${x.id} to ${delegateId}`);
                                                    return this.api.crypto()
                                                        .addDelegationsAndEncryptionKeys(message, x, ownerId, delegateId, sfks.extractedKeys[0], eks.extractedKeys[0])
                                                        .catch(e => {
                                                            console.log("error when sharing message",e);
                                                            return x;
                                                        });
                                                })))));

                                            // share docs
                                            tags.includes("medicalInformation") ||
                                            (tags.includes("all") &&
                                                docs.forEach((x) => (markerPromise = markerPromise.then(() => Promise.all([
                                                    this.api.crypto().extractDelegationsSFKs(x, ownerId),
                                                    this.api.crypto().extractEncryptionsSKs(x, ownerId)
                                                ]).then(([sfks, eks]) => {
                                                    console.log(`share message ${message.id} doc ${x.id} to ${delegateId}`);
                                                    return this.api.crypto()
                                                        .addDelegationsAndEncryptionKeys(message, x, ownerId, delegateId, sfks.extractedKeys[0], eks.extractedKeys[0])
                                                        .catch(e => {
                                                            console.log("error when sharing message",e);
                                                            return x;
                                                        });
                                                })))));
                                        });

                                        // apply new delegations in DB
                                        return markerPromise
                                            .then(() => {
                                                console.log("sid");
                                                return (((allTags.includes("financialInformation") ||
                                                    allTags.includes("all")) &&
                                                    (ivs && ivs.length && !_.isEqual(oInvs, ivs)) &&
                                                    this.api.invoice()
                                                        .setInvoicesDelegations(ivs)
                                                        .then(() => (status.invoices.success = true))
                                                        .catch(e => {
                                                            console.log(e)
                                                            return (status.invoices.error = e);
                                                        })) ||
                                                    Promise.resolve((status.invoices.success = true)));
                                            })
                                            .then(() => {
                                                console.log("sdd");
                                                return (((allTags.includes("medicalInformation") || allTags.includes("all")) &&
                                                    (docs && docs.length && !_.isEqual(oDocs, docs)) &&
                                                    this.api.document()
                                                        .setDocumentsDelegations(docs)
                                                        .then(() => (status.documents.success = true))
                                                        .catch(e => {
                                                            console.log(e)
                                                            return (status.documents.error = e);
                                                        })) ||
                                                    Promise.resolve((status.documents.success = true)));
                                            })
                                            .then(() => this.api.message().modifyMessage(message))
                                            .then(p => {
                                                status.message.success = true;
                                                return { message: p, statuses: status };
                                            })
                                            .catch(e => {
                                                console.log(e)
                                                status.message.error = e;
                                                return { message: message, statuses: status };
                                            });
                                    });
                                })
                                : this.api.message().modifyMessage( _.assign(message, {
                                    delegations: _.assign(message.delegations, delegateIds
                                        .filter(id => !message.delegations || !message.delegations[id]) //If there are delegations do not modify
                                        .reduce((acc, del) => Object.assign(acc, _.fromPairs([[del, []]])), message.delegations || {}))
                                }))
                                    .then(p => {
                                        status.message.success = true;
                                        return { message: p, statuses: status };
                                    })
                                    .catch(e => {
                                        console.log(e)
                                        status.message.error = e;
                                        return { message: message, statuses: status };
                                    });
                        });
                    });
                });
            }

            extractDelegationsSFKsAndEncryptionSKs( ety, ownerId) {
                const delegationsSfksOwnerPromise = this.api.crypto().extractDelegationsSFKs(ety, ownerId)
                    .then(xks => xks.extractedKeys) //Will climb up hierarchy
                const encryptionKeysOwnerPromise = this.api.crypto().extractEncryptionsSKs(ety, ownerId)
                    .then(xks => xks.extractedKeys) //Will climb up hierarchy

                return Promise.all([delegationsSfksOwnerPromise, encryptionKeysOwnerPromise])
            }

            api_document_findDelegationsStubsByHCPartyMessageSecretFKeys(ownerId, sFKs) {
                return this.api.document().findByHCPartyMessageSecretFKeys(ownerId, sFKs)
            }


        }

        customElements.define(HtAdminToolsShareMessages.is, HtAdminToolsShareMessages)
    </script>
</dom-module>
